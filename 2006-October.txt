From dave at smartrak.biz  Wed Oct  4 06:43:23 2006
From: dave at smartrak.biz (Dave Leaver)
Date: Wed, 4 Oct 2006 17:43:23 +1300
Subject: [Mapnik-devel] BOOST_FOREACH
Message-ID: <236B4D6E6137CE4BBA94F247930D63BE02C182@stkdns.smartrak.biz>

I've just updated my mapnik to the latest svn.

boost/foreach.hpp doesn't exist in boost yet, just wondering where you got it from and what other bits it needs?
I've checked the boost.org archives for the file, but can only find the one in boost/test/utils/

Thanks.
Dave.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/mapnik-devel/attachments/20061004/fa56ad5c/attachment.html>

From artem at pavlenko.uklinux.net  Wed Oct  4 13:40:13 2006
From: artem at pavlenko.uklinux.net (Artem Pavlenko)
Date: Wed, 04 Oct 2006 12:40:13 +0100
Subject: [Mapnik-devel] BOOST_FOREACH
In-Reply-To: <236B4D6E6137CE4BBA94F247930D63BE02C182@stkdns.smartrak.biz>
References: <236B4D6E6137CE4BBA94F247930D63BE02C182@stkdns.smartrak.biz>
Message-ID: <45239D9D.9030903@pavlenko.uklinux.net>

Yep, BOOST_FOREACH is in boost-1_35 from cvs .  I will re-write map 
loader to use Iterators or std::for_each for now.
Thanks!
Artem


Dave Leaver wrote:
>
> I've just updated my mapnik to the latest svn.
>
> boost/foreach.hpp doesn't exist in boost yet, just wondering where you 
> got it from and what other bits it needs?
> I've checked the boost.org archives for the file, but can only find 
> the one in boost/test/utils/
>
> Thanks.
> Dave.
>
> ------------------------------------------------------------------------
>
> _______________________________________________
> Mapnik-devel mailing list
> Mapnik-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/mapnik-devel
>   


From pavlenko at users.berlios.de  Wed Oct  4 13:40:59 2006
From: pavlenko at users.berlios.de (Artem Pavlenko)
Date: Wed, 04 Oct 2006 12:40:59 +0100
Subject: [Mapnik-devel] New Mapnik Features
Message-ID: <45239DCB.7070904@users.berlios.de>

Hello, List!

I'm looking into new features to implement in mapnik.  My list so far:
1. uniform at_point query ( datasorce interface).
2. projections  transformation support based on proj4.
3. in-memory datasources and in-line feature/geometry creation (perhaps 
from WKT)
Anything missing?

Some feedback would be very useful!

Cheers
Artem


From robert.coup at onetrackmind.co.nz  Thu Oct 26 03:14:53 2006
From: robert.coup at onetrackmind.co.nz (Robert Coup)
Date: Thu, 26 Oct 2006 14:14:53 +1300
Subject: [Mapnik-devel] Text wrapping patch
Message-ID: <45400C0D.5070509@onetrackmind.co.nz>

Hi All,

Patch for text wrapping enclosed - see notes below.

Thanks,

Robert Coup

-- 
One Track Mind Ltd.
PO Box 1604, Shortland St, Auckland, New Zealand
Phone +64-9-966 0433 Mobile +64-21-572 632
Web http://www.onetrackmind.co.nz 



-------- Original Message --------
Subject: 	Mapnik text wrapping patch
Date: 	Thu, 26 Oct 2006 13:47:39 +1300
From: 	Toby Collett <toby.collett at onetrackmind.co.nz>
To: 	Robert Coup <robert.coup at onetrackmind.co.nz>
References: 	<453E8318.7070805 at onetrackmind.co.nz>



The attached patch (against SVN head 26/10) adds the
ability to wrap text either at a fixed width or with a target
width/height ratio. It will only break words on spaces and will wrap
below the wrap width rather than letting words flow over it.

The ratio targets are naive with no search being performed, but this
does mean it should run fairly fast. 

Non breaking spaces should be respected, hyphens are not considered a
break point at this stage (feel free to add a list of breakable
characters...)

Below is a simple example of setting the wrap width and ratio. Both are 
optional. If the ratio is set then the width is taken as the minimum 
width that text must exceed before wrapping, if ratio is not set the 
wrap_width is used directly.

        txt = TextSymbolizer('name', 'Bitstream Vera Sans Roman', 10, Color('black'))
        txt.halo_fill = Color('white')
        txt.halo_radius = 1
        txt.wrap_width = 30
        txt.text_ratio = 20

Toby

-------------- next part --------------
A non-text attachment was scrubbed...
Name: mapnik_text_wrap.diff
Type: text/x-patch
Size: 13741 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/mapnik-devel/attachments/20061026/1f880b42/attachment.bin>

From artem at pavlenko.uklinux.net  Thu Oct 26 22:02:50 2006
From: artem at pavlenko.uklinux.net (Artem Pavlenko)
Date: Thu, 26 Oct 2006 21:02:50 +0100
Subject: [Mapnik-devel] Text wrapping patch
In-Reply-To: <45400C0D.5070509@onetrackmind.co.nz>
References: <45400C0D.5070509@onetrackmind.co.nz>
Message-ID: <4541146A.3070601@pavlenko.uklinux.net>

Robert,

Thanks a lot for contributing this patch. I didn't have a chance to play 
with it yet, I'll do it tomorrow.
I think it will be great to have text wrapping for things like 
lakes,parks etc.

Cheers,
Artem

Robert Coup wrote:
> Hi All,
>
> Patch for text wrapping enclosed - see notes below.
>
> Thanks,
>
> Robert Coup
>
> ------------------------------------------------------------------------
>
> Index: include/mapnik/font_engine_freetype.hpp
> ===================================================================
> --- include/mapnik/font_engine_freetype.hpp	(revision 355)
> +++ include/mapnik/font_engine_freetype.hpp	(working copy)
> @@ -219,8 +219,7 @@
>              : pixmap_(pixmap),
>                face_(face),
>                fill_(0,0,0), 
> -              halo_fill_(255,255,255),
> -              halo_radius_(0) {}
> +              halo_fill_(255,255,255) {}
>      
>          void set_pixel_size(unsigned size)
>          {
> @@ -264,7 +263,9 @@
>                  double x, y, angle;
>                  
>                  path->vertex(&c, &x, &y, &angle);
> +//                std::clog << "   prepare_glyph: " << (unsigned char)c << "," << x << "," << y << "," << angle << std::endl;
>  
> +
>                  FT_BBox glyph_bbox; 
>                  FT_Glyph image;
>  		
> @@ -363,8 +364,8 @@
>                
>                  width += char_dim.first;
>                  height = char_dim.second > height ? char_dim.second : height;
> +                
>              }
> -            
>              info->set_dimensions(width, height);
>          }
>  	
> @@ -376,6 +377,9 @@
>  	    
>              start.x = unsigned(x0 * (1 << 6)); 
>              start.y = unsigned((height - y0) * (1 << 6));
> +
> +//            std::clog << "Render text at: " << x0 << "," << y0 << " " << start.x << "," << start.y << std::endl;
> +
>              // now render transformed glyphs
>              typename glyphs_t::iterator pos;
>  
> @@ -463,6 +467,8 @@
>          mapnik::Color fill_;
>          mapnik::Color halo_fill_;
>          int halo_radius_;
> +        unsigned text_ratio_;
> +        unsigned wrap_width_;
>          glyphs_t glyphs_;
>      }; 
>  }
> Index: include/mapnik/placement_finder.hpp
> ===================================================================
> --- include/mapnik/placement_finder.hpp	(revision 355)
> +++ include/mapnik/placement_finder.hpp	(working copy)
> @@ -67,14 +67,17 @@
>      double starting_y;
>      
>      text_path path;
> +
>      
> -    
>      //helpers
>      std::pair<double, double> get_position_at_distance(double target_distance);
>      double get_total_distance();
>      void clear_envelopes();
>      
>      double total_distance_; //cache for distance
> +    
> +    int wrap_width;
> +    int text_ratio;
>    };
>    
>    class placement_finder : boost::noncopyable
> Index: include/mapnik/text_symbolizer.hpp
> ===================================================================
> --- include/mapnik/text_symbolizer.hpp	(revision 355)
> +++ include/mapnik/text_symbolizer.hpp	(working copy)
> @@ -42,6 +42,10 @@
>          text_symbolizer(text_symbolizer const& rhs);
>          text_symbolizer& operator=(text_symbolizer const& rhs);
>          std::string const& get_name() const;
> +        unsigned get_text_ratio() const; // target ratio for text bounding box in pixels
> +        void set_text_ratio(unsigned ratio);
> +        unsigned get_wrap_width() const; // target ratio for text bounding box in pixels
> +        void set_wrap_width(unsigned ratio);
>          unsigned get_text_size() const;
>  	std::string const& get_face_name() const;
>          Color const& get_fill() const;
> @@ -59,6 +63,8 @@
>          std::string name_;
>    std::string face_name_;
>          unsigned size_;
> +        unsigned text_ratio_;
> +        unsigned wrap_width_;
>          Color fill_;
>          Color halo_fill_;
>          unsigned halo_radius_;
> Index: src/placement_finder.cpp
> ===================================================================
> --- src/placement_finder.cpp	(revision 355)
> +++ src/placement_finder.cpp	(working copy)
> @@ -26,6 +26,7 @@
>  //stl
>  #include <string>
>  #include <vector>
> +#include <assert.h>
>  
>  // boost
>  #include <boost/shared_ptr.hpp>
> @@ -41,13 +42,13 @@
>  namespace mapnik
>  {
>    placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_)
> -    : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0)
> +    : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0)
>    {
>    }
>    
>    //For text
>    placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_)
> -    : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0)
> +    : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0)
>    {
>    }
>    
> @@ -372,6 +373,7 @@
>      return true;
>    }
>    
> +
>    bool placement_finder::build_path_horizontal(placement *p, double target_distance)
>    {
>      double x, y;
> @@ -382,9 +384,76 @@
>      double string_width = string_dimensions.first;
>      double string_height = string_dimensions.second;
>      
> -    x = -string_width/2.0;
> -    y = -string_height/2.0 + 1.0;
> +    // check if we need to wrap the string
> +    double wrap_at = string_width + 1;
> +    if (p->wrap_width && string_width > p->wrap_width)
> +    {
> +        if (p->text_ratio)
> +            for (int i = 1; ((wrap_at = string_width/i)/(string_height*i)) > p->text_ratio && (string_width/i) > p->wrap_width; ++i);
> +        else
> +            wrap_at = p->wrap_width;
> +        //std::clog << "Wrapping string at" << wrap_at << std::endl;
> +    }
> +
> +    // work out where our line breaks need to be
> +    std::vector<int> line_breaks;
> +    std::vector<double> line_widths;
> +    if (wrap_at < string_width && p->info->num_characters() > 0)
> +    {
> +        int line_count=0; 
> +        int last_space = 0;
> +        string_width = 0;
> +        string_height = 0;
> +        double line_width = 0;
> +        double line_height = 0;
> +        double word_width = 0;
> +        double word_height = 0;
> +        for (unsigned int ii = 0; ii < p->info->num_characters(); ii++)
> +        {
> +            character_info ci;;
> +            ci = p->info->at(ii);
> +            
> +            unsigned c = ci.character;
> +            word_width += ci.width;
> +            word_height = word_height > ci.height ? word_height : ci.height;
> +            ++line_count;
>      
> +            if (c == ' ')
> +            {
> +                last_space = ii;
> +                line_width += word_width;
> +                line_height = line_height > word_height ? line_height : word_height;
> +                word_width = 0;
> +                word_height = 0;
> +            }
> +            if (line_width > 0 && line_width > wrap_at)
> +            {
> +                string_width = string_width > line_width ? string_width : line_width;
> +                string_height += line_height;
> +                line_breaks.push_back(last_space);
> +                line_widths.push_back(line_width);
> +                ii = last_space;
> +                line_count = 0;
> +                line_width = 0;
> +                line_height = 0;
> +                word_width = 0;
> +                word_height = 0;
> +            }
> +        }
> +        line_width += word_width;
> +        string_width = string_width > line_width ? string_width : line_width;
> +        line_breaks.push_back(p->info->num_characters() + 1);
> +        line_widths.push_back(line_width);
> +    }
> +    if (line_breaks.size() == 0)
> +    {
> +        line_breaks.push_back(p->info->num_characters() + 1);
> +        line_widths.push_back(string_width);
> +    }
> +
> +    p->info->set_dimensions(string_width, string_height);
> +    
> +    assert(p->geom);
>      if (p->geom->type() == LineString)
>      {
>        std::pair<double, double> starting_pos = p->get_position_at_distance(target_distance);
> @@ -403,6 +472,14 @@
>        p->ctrans->forward(&p->starting_x, &p->starting_y);
>      }
>      
> +    double line_height = 0;
> +    unsigned int line_number = 0;
> +    unsigned int index_to_wrap_at = line_breaks[line_number];
> +    double line_width = line_widths[line_number];
> +
> +    x = -line_width/2.0;
> +    y = string_height/2.0;
> +
>      for (unsigned i = 0; i < p->info->num_characters(); i++)
>      {
>          character_info ci;;
> @@ -410,26 +487,38 @@
>          
>          unsigned c = ci.character;
>        
> -        p->path.add_node(c, x, y, 0.0);
> -
> -        Envelope<double> e;
> -        if (p->has_dimensions)
> +        if (i == index_to_wrap_at)
>          {
> -            e.init(p->starting_x - (p->dimensions.first/2.0), p->starting_y - (p->dimensions.second/2.0), p->starting_x + (p->dimensions.first/2.0), p->starting_y + (p->dimensions.second/2.0));
> +            index_to_wrap_at = line_breaks[++line_number];
> +            line_width = line_widths[line_number];
> +            y -= line_height;
> +            x = -line_width/2.0;
> +            line_height = 0;
> +            continue;
>          }
>          else
>          {
> -          e.init(p->starting_x + x, p->starting_y - y, p->starting_x + x + ci.width, p->starting_y - y - ci.height);
> +            p->path.add_node(c, x, y, 0.0);
> +
> +            Envelope<double> e;
> +            if (p->has_dimensions)
> +            {
> +                e.init(p->starting_x - (p->dimensions.first/2.0), p->starting_y - (p->dimensions.second/2.0), p->starting_x + (p->dimensions.first/2.0), p->starting_y + (p->dimensions.second/2.0));
> +            }
> +            else
> +            {
> +            e.init(p->starting_x + x, p->starting_y - y, p->starting_x + x + ci.width, p->starting_y - y - ci.height);
> +            }
> +            
> +            if (!detector_.has_placement(e))
> +            {
> +            return false;
> +            }
> +            
> +            p->envelopes.push(e);
>          }
> -        
> -        if (!detector_.has_placement(e))
> -        {
> -          return false;
> -        }
> -        
> -        p->envelopes.push(e);
> -      
>          x += ci.width;
> +        line_height = line_height > ci.height ? line_height : ci.height;
>      }
>      return true;
>    }
> Index: src/text_symbolizer.cpp
> ===================================================================
> --- src/text_symbolizer.cpp	(revision 355)
> +++ src/text_symbolizer.cpp	(working copy)
> @@ -22,6 +22,9 @@
>  
>  //$Id$
>  
> +
> +#include <iostream>
> +
>  #include <mapnik/text_symbolizer.hpp>
>  
>  namespace mapnik
> @@ -30,6 +33,8 @@
>  	: name_(name),
>      face_name_(face_name),
>  	  size_(size),
> +      text_ratio_(0),
> +      wrap_width_(0),
>  	  fill_(fill),
>  	  halo_fill_(Color(255,255,255)),
>  	  halo_radius_(0),
> @@ -41,6 +46,8 @@
>  	: name_(rhs.name_),
>      face_name_(rhs.face_name_),
>  	  size_(rhs.size_),
> +      text_ratio_(rhs.text_ratio_),
> +      wrap_width_(rhs.wrap_width_),
>  	  fill_(rhs.fill_),
>  	  halo_fill_(rhs.halo_fill_),
>  	  halo_radius_(rhs.halo_radius_),
> @@ -55,6 +62,8 @@
>  	name_ = other.name_;
>    face_name_ = other.face_name_;
>  	size_ = other.size_;
> +    text_ratio_ = other.text_ratio_,
> +    wrap_width_ = other.wrap_width_,
>  	fill_ = other.fill_;
>  	halo_fill_ = other.halo_fill_;
>  	label_p_ = other.label_p_;
> @@ -73,6 +82,26 @@
>  	return face_name_;
>      }
>      
> +    unsigned  text_symbolizer::get_text_ratio() const
> +    {
> +    return text_ratio_;
> +    }
> +
> +    void  text_symbolizer::set_text_ratio(unsigned ratio) 
> +    {
> +        text_ratio_ = ratio;
> +    }
> +
> +    unsigned  text_symbolizer::get_wrap_width() const
> +    {
> +    return wrap_width_;
> +    }
> +
> +    void  text_symbolizer::set_wrap_width(unsigned width) 
> +    {
> +        wrap_width_ = width;
> +    }
> +
>      unsigned  text_symbolizer::get_text_size() const
>      {
>  	return size_;
> Index: src/agg_renderer.cpp
> ===================================================================
> --- src/agg_renderer.cpp	(revision 355)
> +++ src/agg_renderer.cpp	(working copy)
> @@ -502,6 +502,8 @@
>                      ren.get_string_info(text, &info);
>                   
>                      placement text_placement(&info, &t_, &prj_trans, geom, sym.get_label_placement());
> +                    text_placement.text_ratio = sym.get_text_ratio();
> +                    text_placement.wrap_width = sym.get_wrap_width();
>                    
>                      bool found = finder_.find_placement(&text_placement);
>                      if (!found) {
> Index: bindings/python/mapnik/ogcserver/common.py
> ===================================================================
> --- bindings/python/mapnik/ogcserver/common.py	(revision 355)
> +++ bindings/python/mapnik/ogcserver/common.py	(working copy)
> @@ -384,4 +384,4 @@
>  class Projection(MapnikProjection):
>      
>      def epsgstring(self):
> -        return self.params().split('=')[1].upper()
> \ No newline at end of file
> +        return self.params().split('=')[1].upper()
> Index: bindings/python/mapnik_text_symbolizer.cpp
> ===================================================================
> --- bindings/python/mapnik_text_symbolizer.cpp	(revision 355)
> +++ bindings/python/mapnik_text_symbolizer.cpp	(working copy)
> @@ -43,6 +43,12 @@
>                        &text_symbolizer::get_halo_fill,
>                        return_value_policy<copy_const_reference>()),
>                        &text_symbolizer::set_halo_fill)
> +        .add_property("wrap_width",
> +                      &text_symbolizer::get_wrap_width,
> +                      &text_symbolizer::set_wrap_width)
> +        .add_property("text_ratio",
> +                      &text_symbolizer::get_text_ratio,
> +                      &text_symbolizer::set_text_ratio)
>          .add_property("halo_radius",
>                        &text_symbolizer::get_halo_radius, 
>                        &text_symbolizer::set_halo_radius)
>
>   
> ------------------------------------------------------------------------
>
> _______________________________________________
> Mapnik-devel mailing list
> Mapnik-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/mapnik-devel
>   


From artem at pavlenko.uklinux.net  Thu Oct 26 22:08:28 2006
From: artem at pavlenko.uklinux.net (Artem Pavlenko)
Date: Thu, 26 Oct 2006 21:08:28 +0100
Subject: [Mapnik-devel] Mapnik Web demo!
Message-ID: <454115BC.1050206@pavlenko.uklinux.net>

Hello all!

I put together a very simple 'Google Hack' demo at 
http://media.mapnik.org/tiling.html. 
Please, have a look and let me know if anything can be done better.

Cheers,
Artem



From toby.collett at onetrackmind.co.nz  Mon Oct 30 22:51:43 2006
From: toby.collett at onetrackmind.co.nz (Toby Collett)
Date: Tue, 31 Oct 2006 10:51:43 +1300
Subject: [Mapnik-devel] Patch for repeated labels
Message-ID: <1162245104.13862.5.camel@torpedo.onetrackmind.co.nz>

Hi,
Attached is a patch that allows repeated labels to be placed on a line
geometry (such as roads).

set the label_spacing property on your text symboliser to the space you
want between your repeated labels.

Toby Collett
One Track Mind
-------------- next part --------------
A non-text attachment was scrubbed...
Name: label_repeat.diff
Type: text/x-patch
Size: 26495 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/mapnik-devel/attachments/20061031/794ce8c4/attachment.bin>

From artem at pavlenko.uklinux.net  Mon Oct 30 23:46:54 2006
From: artem at pavlenko.uklinux.net (Artem Pavlenko)
Date: Mon, 30 Oct 2006 22:46:54 +0000
Subject: [Mapnik-devel] Patch for repeated labels
In-Reply-To: <1162245104.13862.5.camel@torpedo.onetrackmind.co.nz>
References: <1162245104.13862.5.camel@torpedo.onetrackmind.co.nz>
Message-ID: <454680DE.2020803@pavlenko.uklinux.net>

Excellent!  I'll try it tomorrow, it's getting late over here.
Artem.

Toby Collett wrote:
> Hi,
> Attached is a patch that allows repeated labels to be placed on a line
> geometry (such as roads).
>
> set the label_spacing property on your text symboliser to the space you
> want between your repeated labels.
>
> Toby Collett
> One Track Mind
>   
> ------------------------------------------------------------------------
>
> Index: include/mapnik/placement_finder.hpp
> ===================================================================
> --- include/mapnik/placement_finder.hpp	(revision 362)
> +++ include/mapnik/placement_finder.hpp	(working copy)
> @@ -36,6 +36,15 @@
>  
>  namespace mapnik
>  {
> +
> +    struct placement_element
> +    {
> +        double starting_x;
> +        double starting_y;
> +    
> +        text_path path;
> +    };
> +
>    struct placement
>    {
>      typedef  coord_transform2<CoordTransform,geometry_type> path_type;
> @@ -63,11 +72,10 @@
>      std::queue< Envelope<double> > envelopes;
>      
>      //output
> -    double starting_x;
> -    double starting_y;
> -    
> -    text_path path;
> +    std::vector<placement_element> placements;
>  
> +    // caching output
> +    placement_element current_placement;
>      
>      //helpers
>      std::pair<double, double> get_position_at_distance(double target_distance);
> @@ -78,14 +86,18 @@
>      
>      int wrap_width;
>      int text_ratio;
> +
> +    int label_spacing; // distance between repeated labels on a single geometry
>    };
> +
> +
>    
>    class placement_finder : boost::noncopyable
>    {
>    public:
>      placement_finder(Envelope<double> e);
>    
> -    bool find_placement(placement *placement);
> +    bool find_placements(placement *p);
>      
>    protected:
>      bool find_placement_follow(placement *p);
> Index: include/mapnik/text_path.hpp
> ===================================================================
> --- include/mapnik/text_path.hpp	(revision 362)
> +++ include/mapnik/text_path.hpp	(working copy)
> @@ -93,9 +93,9 @@
>        }
>      };
>      
> -    struct text_path : private boost::noncopyable
> +    struct text_path 
>      {
> -        struct character_node : boost::noncopyable
> +        struct character_node
>          {
>              int c;
>              double x, y, angle;
> @@ -112,7 +112,7 @@
>              }
>          };
>  
> -        typedef boost::ptr_vector<character_node> character_nodes_t;
> +        typedef std::vector<character_node> character_nodes_t;
>          
>          character_nodes_t nodes_;
>          int itr_;
> @@ -120,11 +120,17 @@
>          std::pair<unsigned,unsigned> string_dimensions;
>          
>          text_path() :  itr_(0) {} 
> +        text_path(const text_path & other) : itr_(0)
> +        {
> +            nodes_ = other.nodes_;
> +            string_dimensions = other.string_dimensions;
> +        }
> + 
>          ~text_path() {}
>            
>          void add_node(int c, double x, double y, double angle)
>          {
> -            nodes_.push_back(new character_node(c, x, y, angle));
> +            nodes_.push_back(character_node(c, x, y, angle));
>          }
>          
>          void vertex(int *c, double *x, double *y, double *angle)
> Index: include/mapnik/text_symbolizer.hpp
> ===================================================================
> --- include/mapnik/text_symbolizer.hpp	(revision 362)
> +++ include/mapnik/text_symbolizer.hpp	(working copy)
> @@ -45,8 +45,10 @@
>          std::string const& get_name() const;
>          unsigned get_text_ratio() const; // target ratio for text bounding box in pixels
>          void set_text_ratio(unsigned ratio);
> -        unsigned get_wrap_width() const; // target ratio for text bounding box in pixels
> +        unsigned get_wrap_width() const; // width to wrap text at, or trigger ratio
>          void set_wrap_width(unsigned ratio);
> +        unsigned get_label_spacing() const; // spacing between repeated labels on lines
> +        void set_label_spacing(unsigned spacing);
>          unsigned get_text_size() const;
>          std::string const& get_face_name() const;
>          Color const& get_fill() const;
> @@ -66,6 +68,7 @@
>          unsigned size_;
>          unsigned text_ratio_;
>          unsigned wrap_width_;
> +        unsigned label_spacing_;
>          Color fill_;
>          Color halo_fill_;
>          unsigned halo_radius_;
> Index: src/placement_finder.cpp
> ===================================================================
> --- src/placement_finder.cpp	(revision 362)
> +++ src/placement_finder.cpp	(working copy)
> @@ -26,6 +26,7 @@
>  //stl
>  #include <string>
>  #include <vector>
> +#include <assert.h>
>  
>  // boost
>  #include <boost/shared_ptr.hpp>
> @@ -41,13 +42,13 @@
>  namespace mapnik
>  {
>      placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, std::pair<double, double> dimensions_)
> -        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0)
> +        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(point_placement), dimensions(dimensions_), has_dimensions(true), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0)
>      {
>      }
> -  
> +
>      //For text
>      placement::placement(string_info *info_, CoordTransform *ctrans_, const proj_transform *proj_trans_, geometry_ptr geom_, label_placement_e placement_)
> -        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0)
> +        : info(info_), ctrans(ctrans_), proj_trans(proj_trans_), geom(geom_), label_placement(placement_), has_dimensions(false), shape_path(*ctrans_, *geom_, *proj_trans_), total_distance_(-1.0), wrap_width(0), text_ratio(0), label_spacing(0)
>      {
>      }
>    
> @@ -132,11 +133,12 @@
>    
>    
>      placement_finder::placement_finder(Envelope<double> e)
> -        : detector_(e)
> +      : detector_(e)
>      {
>      }
>  
> -    bool placement_finder::find_placement(placement *p)
> +
> +    bool placement_finder::find_placements(placement *p)
>      {
>          if (p->label_placement == point_placement)
>          {
> @@ -156,32 +158,61 @@
>          double string_width = string_dimensions.first;
>          //    double string_height = string_dimensions.second;
>      
> +
> +        std::clog << "trying to place string: ";
> +        for (unsigned int ii = 0; ii < p->info->num_characters(); ++ii)
> +            std::clog << static_cast<char> (p->info->at(ii).character);
> +        std::clog << std::endl;
> +
>          double distance = p->get_total_distance();
>      
> -        //~ double delta = string_width/distance;
> -        double delta = distance/100.0;
> +        if (string_width > distance)
> +        {
> +            std::clog << "String longer than segment, bailing" << std::endl;
> +            return false;
> +        }
> +
>      
> -        for (double i = 0; i < (distance - string_width)/2.0; i += delta)
> +        int num_labels = 0;
> +        if (p->label_spacing)
> +            num_labels = static_cast<int> (floor(distance / (p->label_spacing + string_width)));
> +        if (num_labels == 0)
> +            num_labels = 1;
> +
> +        double ideal_spacing = distance/num_labels;
> +        std::vector<double> ideal_label_distances;
> +        for (double label_pos = ideal_spacing/2; label_pos < distance; label_pos += ideal_spacing)
> +            ideal_label_distances.push_back(label_pos);
> +
> +        double delta = distance/100.0;
> +        bool FoundPlacement = false;
> +        for (std::vector<double>::const_iterator itr = ideal_label_distances.begin(); itr < ideal_label_distances.end(); ++itr)
>          {
> -            p->clear_envelopes();
> -      
> -            if ( build_path_follow(p, (distance - string_width)/2.0 + i) ) {
> -                update_detector(p);
> -                return true;
> +            std::clog << "Trying to find txt placement at distance: " << *itr << std::endl;
> +            for (double i = 0; i < ideal_spacing; i += delta)
> +            {
> +                p->clear_envelopes();
> +        
> +                // check position +- delta for valid placement
> +                if ( build_path_follow(p, *itr - string_width/2 + i)) {
> +                    update_detector(p);
> +                    FoundPlacement = true;
> +                    break;
> +                }
> +
> +                p->clear_envelopes();
> +                if (build_path_follow(p, *itr - string_width/2 - i) ) {
> +                    update_detector(p);
> +                    FoundPlacement = true;
> +                    break;
> +                }
>              }
> -      
> -            p->clear_envelopes();
> -      
> -            if ( build_path_follow(p, (distance - string_width)/2.0 - i) ) {
> -                update_detector(p);
> -                return true;
> -            }
> -        }
> +        }    
>      
> -        p->starting_x = 0;
> -        p->starting_y = 0;
> -    
> -        return false;
> +        if (FoundPlacement)
> +            std::clog << "Found Placement" << string_width << " " << distance << std::endl;
> +
> +        return FoundPlacement;
>      }
>    
>      bool placement_finder::find_placement_horizontal(placement *p)
> @@ -206,10 +237,6 @@
>                  return true;
>              }
>          }
> -    
> -        p->starting_x = 0;
> -        p->starting_y = 0;
> -    
>          return false;
>      }
>    
> @@ -226,14 +253,14 @@
>      }
>  
>      bool placement_finder::build_path_follow(placement *p, double target_distance)
> -    {
> +     {
>          double new_x, new_y, old_x, old_y;
>          unsigned cur_node = 0;
>  
>          double angle = 0.0;
>          int orientation = 0;
>      
> -        p->path.clear();
> +        p->current_placement.path.clear();
>      
>          double x, y;
>          x = y = 0.0;
> @@ -265,9 +292,9 @@
>              distance += segment_length;
>              if (distance > target_distance)
>              {
> -                p->starting_x = new_x - dx*(distance - target_distance)/segment_length;
> -                p->starting_y = new_y - dy*(distance - target_distance)/segment_length;
> -
> +                p->current_placement.starting_x = new_x - dx*(distance - target_distance)/segment_length;
> +                p->current_placement.starting_y = new_y - dy*(distance - target_distance)/segment_length;
> +    
>                  angle = atan2(-dy, dx);
>  
>                  if (angle > M_PI/2 || angle <= -M_PI/2) {
> @@ -282,13 +309,14 @@
>                  break;
>              }
>          }
> -
> +    
>          for (unsigned i = 0; i < p->info->num_characters(); i++)
>          {
>              character_info ci;
>              unsigned c;
> -      
> -            while (distance <= 0) {
> +    
> +            while (distance <= 0) 
> +            {
>                  double dx, dy;
>  
>                  cur_node++;
> @@ -332,7 +360,7 @@
>                  //Center the text on the line.
>                  x += (((double)string_height/2.0) - 1.0)*cos(angle+M_PI/2);
>                  y -= (((double)string_height/2.0) - 1.0)*sin(angle+M_PI/2);
> -          
> +        
>                  if (!p->has_dimensions)
>                  {
>                      e.init(x, y, x + ci.width*cos(angle+M_PI), y - ci.width*sin(angle+M_PI));
> @@ -364,87 +392,26 @@
>          
>              p->envelopes.push(e);
>          
> -            p->path.add_node(c, x - p->starting_x, -y + p->starting_y, (orientation == -1 ? angle + M_PI : angle));
> +            p->current_placement.path.add_node(c, x - p->current_placement.starting_x, -y + p->current_placement.starting_y, (orientation == -1 ? angle + M_PI : angle));
>          
>              distance -= ci.width;
>          }
> -    
> +        p->placements.push_back(p->current_placement);
> +
>          return true;
>      }
>  
> -    /*
> -   bool placement_finder::build_path_horizontal(placement *p, double target_distance)
> -  {
> -    double x, y;
> -  
> -    p->path.clear();
> -    
> -    std::pair<double, double> string_dimensions = p->info->get_dimensions();
> -    double string_width = string_dimensions.first;
> -    double string_height = string_dimensions.second;
> -    
> -    x = -string_width/2.0;
> -    y = -string_height/2.0 + 1.0;
> -    
> -    if (p->geom->type() == LineString)
> -    {
> -      std::pair<double, double> starting_pos = p->get_position_at_distance(target_distance);
> -      
> -      p->starting_x = starting_pos.first;
> -      p->starting_y = starting_pos.second;
> -    }
> -    else
> -    {
> -      p->geom->label_position(&p->starting_x, &p->starting_y);
> -      //  TODO: 
> -      //  We would only want label position in final 'paper' coords.
> -      //  Move view and proj transforms to e.g. label_position(x,y,proj_trans,ctrans)?
> -      double z=0;  
> -      p->proj_trans->backward(p->starting_x, p->starting_y, z);
> -      p->ctrans->forward(&p->starting_x, &p->starting_y);
> -    }
> -    
> -    for (unsigned i = 0; i < p->info->num_characters(); i++)
> -    {
> -        character_info ci;;
> -        ci = p->info->at(i);
> -        
> -        unsigned c = ci.character;
> -      
> -        p->path.add_node(c, x, y, 0.0);
>  
> -        Envelope<double> e;
> -        if (p->has_dimensions)
> -        {
> -            e.init(p->starting_x - (p->dimensions.first/2.0), p->starting_y - (p->dimensions.second/2.0), p->starting_x + (p->dimensions.first/2.0), p->starting_y + (p->dimensions.second/2.0));
> -        }
> -        else
> -        {
> -          e.init(p->starting_x + x, p->starting_y - y, p->starting_x + x + ci.width, p->starting_y - y - ci.height);
> -        }
> -        
> -        if (!detector_.has_placement(e))
> -        {
> -          return false;
> -        }
> -        
> -        p->envelopes.push(e);
> -      
> -        x += ci.width;
> -    }
> -    return true;
> -  }
> -    */
> -    
>      bool placement_finder::build_path_horizontal(placement *p, double target_distance)
>      {
> +        double x, y;
>      
> -        p->path.clear();
> -    
> +        p->current_placement.path.clear();
> +        
>          std::pair<double, double> string_dimensions = p->info->get_dimensions();
>          double string_width = string_dimensions.first;
>          double string_height = string_dimensions.second;
> -    
> +        
>          // check if we need to wrap the string
>          double wrap_at = string_width + 1;
>          if (p->wrap_width && string_width > p->wrap_width)
> @@ -455,7 +422,7 @@
>                  wrap_at = p->wrap_width;
>              //std::clog << "Wrapping string at" << wrap_at << std::endl;
>          }
> -
> +    
>          // work out where our line breaks need to be
>          std::vector<int> line_breaks;
>          std::vector<double> line_widths;
> @@ -471,14 +438,14 @@
>              double word_height = 0;
>              for (unsigned int ii = 0; ii < p->info->num_characters(); ii++)
>              {
> -                character_info ci;
> +                character_info ci;;
>                  ci = p->info->at(ii);
> -            
> +                
>                  unsigned c = ci.character;
>                  word_width += ci.width;
>                  word_height = word_height > ci.height ? word_height : ci.height;
>                  ++line_count;
> -    
> +        
>                  if (c == ' ')
>                  {
>                      last_space = ii;
> @@ -511,42 +478,43 @@
>              line_breaks.push_back(p->info->num_characters() + 1);
>              line_widths.push_back(string_width);
>          }
> -
> -        p->info->set_dimensions(string_width, string_height);
>      
> +        p->info->set_dimensions(string_width, string_height);
> +        
> +        assert(p->geom);
>          if (p->geom->type() == LineString)
>          {
>              std::pair<double, double> starting_pos = p->get_position_at_distance(target_distance);
> -      
> -            p->starting_x = starting_pos.first;
> -            p->starting_y = starting_pos.second;
> +            
> +            p->current_placement.starting_x = starting_pos.first;
> +            p->current_placement.starting_y = starting_pos.second;
>          }
>          else
>          {
> -            p->geom->label_position(&p->starting_x, &p->starting_y);
> +            p->geom->label_position(&p->current_placement.starting_x, &p->current_placement.starting_y);
>              //  TODO: 
>              //  We would only want label position in final 'paper' coords.
>              //  Move view and proj transforms to e.g. label_position(x,y,proj_trans,ctrans)?
>              double z=0;  
> -            p->proj_trans->backward(p->starting_x, p->starting_y, z);
> -            p->ctrans->forward(&p->starting_x, &p->starting_y);
> +            p->proj_trans->backward(p->current_placement.starting_x, p->current_placement.starting_y, z);
> +            p->ctrans->forward(&p->current_placement.starting_x, &p->current_placement.starting_y);
>          }
> -    
> +        
>          double line_height = 0;
>          unsigned int line_number = 0;
>          unsigned int index_to_wrap_at = line_breaks[line_number];
>          double line_width = line_widths[line_number];
> -
> -        double x = -line_width/2.0;
> -        double y = -string_height/2.0 + 1.0;
>      
> +        x = -line_width/2.0;
> +        y = string_height/2.0;
> +    
>          for (unsigned i = 0; i < p->info->num_characters(); i++)
>          {
> -            character_info ci;
> +            character_info ci;;
>              ci = p->info->at(i);
> -        
> +            
>              unsigned c = ci.character;
> -      
> +        
>              if (i == index_to_wrap_at)
>              {
>                  index_to_wrap_at = line_breaks[++line_number];
> @@ -558,35 +526,31 @@
>              }
>              else
>              {
> -                p->path.add_node(c, x, y, 0.0);
> -
> +                p->current_placement.path.add_node(c, x, y, 0.0);
> +    
>                  Envelope<double> e;
>                  if (p->has_dimensions)
>                  {
> -                    e.init(p->starting_x - (p->dimensions.first/2.0), 
> -                           p->starting_y - (p->dimensions.second/2.0), 
> -                           p->starting_x + (p->dimensions.first/2.0), 
> -                           p->starting_y + (p->dimensions.second/2.0));
> +                    e.init(p->current_placement.starting_x - (p->dimensions.first/2.0), p->current_placement.starting_y - (p->dimensions.second/2.0), p->current_placement.starting_x + (p->dimensions.first/2.0), p->current_placement.starting_y + (p->dimensions.second/2.0));
>                  }
>                  else
>                  {
> -                    e.init(p->starting_x + x, 
> -                           p->starting_y - y, 
> -                           p->starting_x + x + ci.width, 
> -                           p->starting_y - y - ci.height);
> +                    e.init(p->current_placement.starting_x + x, p->current_placement.starting_y - y, p->current_placement.starting_x + x + ci.width, p->current_placement.starting_y - y - ci.height);
>                  }
> -            
> +                
>                  if (!detector_.has_placement(e))
>                  {
>                      return false;
>                  }
> -            
> +                
>                  p->envelopes.push(e);
>              }
>              x += ci.width;
>              line_height = line_height > ci.height ? line_height : ci.height;
>          }
> +        p->placements.push_back(p->current_placement);
> +    
>          return true;
>      }
> -}
>  
> +} // namespace
> Index: src/text_symbolizer.cpp
> ===================================================================
> --- src/text_symbolizer.cpp	(revision 362)
> +++ src/text_symbolizer.cpp	(working copy)
> @@ -30,17 +30,18 @@
>  namespace mapnik
>  {
>      text_symbolizer::text_symbolizer(std::string const& name, std::string const& face_name, unsigned size,Color const& fill)
> -        : name_(name),
> +	: name_(name),
>            face_name_(face_name),
> -          size_(size),
> +	  size_(size),
>            text_ratio_(0),
>            wrap_width_(0),
> -          fill_(fill),
> -          halo_fill_(Color(255,255,255)),
> -          halo_radius_(0),
> -          label_p_(point_placement),
> -          anchor_(0.0,0.5),
> -          displacement_(0.0,0.0)  {}
> +          label_spacing_(0),
> +	  fill_(fill),
> +	  halo_fill_(Color(255,255,255)),
> +	  halo_radius_(0),
> +	  label_p_(point_placement),
> +	  anchor_(0.0,0.5),
> +	  displacement_(0.0,0.0)  {}
>             
>      text_symbolizer::text_symbolizer(text_symbolizer const& rhs)
>          : name_(rhs.name_),
> @@ -48,6 +49,7 @@
>            size_(rhs.size_),
>            text_ratio_(rhs.text_ratio_),
>            wrap_width_(rhs.wrap_width_),
> +          label_spacing_(rhs.label_spacing_),
>            fill_(rhs.fill_),
>            halo_fill_(rhs.halo_fill_),
>            halo_radius_(rhs.halo_radius_),
> @@ -64,6 +66,7 @@
>          size_ = other.size_;
>          text_ratio_ = other.text_ratio_;
>          wrap_width_ = other.wrap_width_;
> +        label_spacing_ = other.label_spacing_;
>          fill_ = other.fill_;
>          halo_fill_ = other.halo_fill_;
>          halo_radius_ = other.halo_radius_;
> @@ -85,7 +88,7 @@
>      
>      unsigned  text_symbolizer::get_text_ratio() const
>      {
> -        return text_ratio_;
> +    return text_ratio_;
>      }
>  
>      void  text_symbolizer::set_text_ratio(unsigned ratio) 
> @@ -95,14 +98,24 @@
>  
>      unsigned  text_symbolizer::get_wrap_width() const
>      {
> -        return wrap_width_;
> +    return wrap_width_;
>      }
>  
>      void  text_symbolizer::set_wrap_width(unsigned width) 
>      {
>          wrap_width_ = width;
> +    }    
> +
> +    unsigned  text_symbolizer::get_label_spacing() const
> +    {
> +    return label_spacing_;
>      }
>  
> +    void  text_symbolizer::set_label_spacing(unsigned spacing) 
> +    {
> +        label_spacing_ = spacing;
> +    }
> +
>      unsigned  text_symbolizer::get_text_size() const
>      {
>          return size_;
> Index: src/agg_renderer.cpp
> ===================================================================
> --- src/agg_renderer.cpp	(revision 362)
> +++ src/agg_renderer.cpp	(working copy)
> @@ -346,24 +346,26 @@
>                   
>                      placement text_placement(&info, &t_, &prj_trans, geom, std::pair<double, double>(w, h) );
>                      
> -                    bool found = finder_.find_placement(&text_placement);
> +                    bool found = finder_.find_placements(&text_placement);
>                      if (!found) {
>                        return;
>                      }
>                      
> -                    double x = text_placement.starting_x;
> -                    double y = text_placement.starting_y;
> -                    
> -                    int px=int(floor(x - 0.5 * w));
> -                    int py=int(floor(y - 0.5 * h));
> -                    
> -                    pixmap_.set_rectangle_alpha(px,py,*data);
> -            
> -                    Envelope<double> dim = ren.prepare_glyphs(&text_placement.path);
> -                    
> -                    //If has_placement 
> -                    
> -                    ren.render(x,y);
> +
> +                    for (unsigned int ii = 0; ii < text_placement.placements.size(); ++ ii)
> +                    {
> +                        double x = text_placement.placements[ii].starting_x;
> +                        double y = text_placement.placements[ii].starting_y;
> +
> +                        int px=int(floor(x - 0.5 * w));
> +                        int py=int(floor(y - 0.5 * h));
> +                        
> +                        pixmap_.set_rectangle_alpha(px,py,*data);
> +                        
> +                        Envelope<double> dim = ren.prepare_glyphs(&text_placement.placements[ii].path);
> +                        
> +                        ren.render(x,y);
> +                    }
>                  }
>              }
>          }
> @@ -504,25 +506,29 @@
>                      placement text_placement(&info, &t_, &prj_trans, geom, sym.get_label_placement());
>                      text_placement.text_ratio = sym.get_text_ratio();
>                      text_placement.wrap_width = sym.get_wrap_width();
> +                    text_placement.label_spacing = sym.get_label_spacing();
>                    
> -                    bool found = finder_.find_placement(&text_placement);
> +                    bool found = finder_.find_placements(&text_placement);
>                      if (!found) {
>                        return;
>                      }
>                      
> -                    double x = text_placement.starting_x;
> -                    double y = text_placement.starting_y;
> -                    
> -                    Envelope<double> dim = ren.prepare_glyphs(&text_placement.path);
> -                    
> -                    Envelope<double> text_box(x + dim.minx() ,y - dim.maxy(), x + dim.maxx(),y - dim.miny());
> -		    
> -                    if (sym.get_halo_radius() > 0)
> +                    for (unsigned int ii = 0; ii < text_placement.placements.size(); ++ ii)
>                      {
> -                        text_box.width(text_box.width() + sym.get_halo_radius()*2);
> -                        text_box.height(text_box.height() + sym.get_halo_radius()*2);
> +                        double x = text_placement.placements[ii].starting_x;
> +                        double y = text_placement.placements[ii].starting_y;
> +                        
> +                        Envelope<double> dim = ren.prepare_glyphs(&text_placement.placements[ii].path);
> +                        
> +                        Envelope<double> text_box(x + dim.minx() ,y - dim.maxy(), x + dim.maxx(),y - dim.miny());
> +		        
> +                        if (sym.get_halo_radius() > 0)
> +                        {
> +                            text_box.width(text_box.width() + sym.get_halo_radius()*2);
> +                            text_box.height(text_box.height() + sym.get_halo_radius()*2);
> +                        }
> +                        ren.render(x,y);
>                      }
> -                    ren.render(x,y);
>                  }
>              }  
>          }
> Index: bindings/python/mapnik/ogcserver/common.py
> ===================================================================
> --- bindings/python/mapnik/ogcserver/common.py	(revision 362)
> +++ bindings/python/mapnik/ogcserver/common.py	(working copy)
> @@ -384,4 +384,4 @@
>  class Projection(MapnikProjection):
>      
>      def epsgstring(self):
> -        return self.params().split('=')[1].upper()
> \ No newline at end of file
> +        return self.params().split('=')[1].upper()
> Index: bindings/python/mapnik_text_symbolizer.cpp
> ===================================================================
> --- bindings/python/mapnik_text_symbolizer.cpp	(revision 362)
> +++ bindings/python/mapnik_text_symbolizer.cpp	(working copy)
> @@ -49,6 +49,9 @@
>          .add_property("text_ratio",
>                        &text_symbolizer::get_text_ratio,
>                        &text_symbolizer::set_text_ratio)
> +        .add_property("label_spacing",
> +                      &text_symbolizer::get_label_spacing,
> +                      &text_symbolizer::set_label_spacing)
>          .add_property("halo_radius",
>                        &text_symbolizer::get_halo_radius, 
>                        &text_symbolizer::set_halo_radius)
>   
> ------------------------------------------------------------------------
>
> _______________________________________________
> Mapnik-devel mailing list
> Mapnik-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/mapnik-devel
>   


